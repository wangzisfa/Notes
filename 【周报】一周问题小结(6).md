# 【周报】一周问题小结(6)

> 本周学习了并发中的执行器、同步器，复习了流库的相关知识

## 并发

- Callable 泛型接口 和 线程执行器、Future
  - 为什么要使用 Callable 接口？能够在线程执行完任务后，方便地获取执行结果，避免使用 共享变量 或 线程通信 方式的麻烦
  - Callable 接口 一般需要配合 ExecutorService接口 使用，ExecutorService 中包含 submit 方法，以供提交 Callable 接口参数
  - <a href="###Future">Future接口</a> 则是用于对 Callable 或 Runnable 任务的执行结果进行取消、查询、获取结果的。并且在调用后会 **持续阻塞线程** 直至任务返回结果。
- 关于 Executor 线程池的体系UML图

![img](https://img-blog.csdnimg.cn/20200321203636254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70)

来源：https://blog.csdn.net/xiaojin21cen/article/details/81810534

- 线程池中包含生命周期较短的线程，并且有效的减少了并发线程的数目，提高了性能。
- 如果提交的任务数多于空闲的线程数，就把得不到服务的任务放置在队列中，当其他任务完成后在执行它
- 执行器关闭后不再接收新的任务，在所有任务完成后，线程池中的所有线程死亡
- CountDownLatch、Semaphore、CyclicBarrier同步器的应用场景

## 流库

- 流不存储其元素
- 流操作不更改其数据源，而是生成一个新的流
- 惰性执行（需要其结果时，操作才会执行
- 约简：将流约简为可在程序中使用的非流值 eg: `Optional<String> largest = words.max(String::compareToIgnoreCase);`
- Optional类型变量永远都不应为null
- Optional 转化为 流 的操作
- 收集流库中的结果



## 关于下周

- 继续学习 JDBC
- 开始学习HTML与CSS
- 正则表达式





















## 补注

### Future

- cancel 取消正在执行却未执行完毕的任务，取消成功返回 true，失败false
- isCancelled 
- isDone
- get






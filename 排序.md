# 排序

## 归并排序

是一种基于二分法（分治法）实现的排序

伪码：

```CQL
void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd) {
    LeftEnd = R - 1;
    Tmp = L;
    NumElements = RightEnd - L + 1;
    while (L <= LeftEnd && R <= RightEnd ) {
        if ( A[L] <= A[R] )		TmpA[Tmp++] = A[L++];
        else					TmpA[Tmp++] = A[R++];
    }
    while ( L <= LeftEnd )
        TmpA[Tmp++] = A[L++];
    while ( R <= RightEnd )
        TmpA[Tmp++] = A[R++];
    for ( i = 0; i < NumElements; i++, RightEnd-- )
        A[RightEnd] = TmpA[RightEnd];
}
```

## 快速排序

是一种基于二分法（分治法）实现的排序

思路：

1. 先设置pivot（中心轴），一般来说以数组的第一个元素为pivot，并将pivot复制一份在temp中
2. 左边哨兵left， 右边哨兵为 right
3. 右边哨兵位置与pivot比较，比pivot大的不变，并将哨兵左移。比pivot小的移动至pivot位置，并左移
4. 左边同理。直到左右哨兵相遇，将temp中的pivot放在相遇位置
5. 再次设置pivot。（这是一个递归的过程）
6. 直到不可再分为止（哨兵设置时相遇 或 元素只有一个）

```c
void quick_sort(int a[], int left, int right) {
    int temp;
    if ()
    while ()
}
```





















## 插入排序

思路:

先将待排序的数存储在temp中，直接将temp所指的位置的元素用已排序的最后一位刷掉，再将temp中的值与已排序的数挨个比较，如果temp小于已排序，就将已排序的元素向后覆盖一位。直到temp大于已排序的值。如果此时已经到达数组的首位，直接用temp覆盖首位。

```c
void insertion_sort(int a[], int n) {
    int tmp;
    int i, j;
    for (i = 1; i < n; i++) {//从1开始是因为默认第一位已排序
        tmp = a[i];
        j = i - 1;
        while (j >= 0 && a[j] > tmp) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = tmp;
    }
}
```

## 选择排序

从第一个元素开始，默认为最小值，开始遍历。直到找到一个比这个值更小的**最小的**一个元素，然后两个元素交换，循环数组中的第二个元素。

```c
void selection_sort(int a[], int n) {
    int i;
    int j;
    int tmp;
    int min;
    int flag;
    for (i = 0; i < n - 1; i++) {
        min = i;
        for (j = i; j < n; j++) {
            if (a[j] < a[min])  min = j;
        }
        tmp = a[min];
        a[min] = a[i];
        a[i] = tmp;
        if (i != min) flag++;//用于计数交换了多少次
    }
}
```

## 桶排序（1~10^7)
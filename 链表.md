# 链表

## 单向链表

单向链表是指， 该链表是一个线性的链接在一起的数据块。

具体实现步骤如下：

```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

struct node {
	int n;
	struct node* next;
};

struct node* creat(int n);

int main(void) {
	int n;
	cin >> n;
	struct node* head;
	head = creat(n);
	
	for (int i = 0; i < n; i++) {
		cout << head->n;
		cout << " ";
		head = head->next;
	}

	return 0;
}

struct node* creat(int n) {
	struct node* head, * cur, * p;
	int rest = n - 1;
	head = new struct node;
	cin >> head->n;
	head->next = NULL;
	cur = head;
	while (rest--) {
		p = new struct node;
		cin >> p->n;
		p->next = NULL;
		cur->next = p;
		cur = p;
	}
	return head;
}
```

注意：

1. 在链接过程中不要忘记把每一步的结构体变量中的**结构体指针**初始化**NULL**
2. 头指针也需要在开始时初始化NULL
3. 此方法为后插法，前插法更为简单



链表的插入和删除

1. 插入
   1. 将cur的next指向新插入的节点的地址
   2. 新节点的next指向prev
2. 删除
   1. 如果头节点是需要删除的节点，直接将head的next赋给head
   2. 如果prev是需要删除的节点，prev先指向下一位，cur指向prev
   3. 如果prev是最后一位元素，直接将cur的next指向null



## 模拟链表

模拟链表是指在数组中构建出链表的方式。





## 完整版链表（crud）

```c
#include<stdio.h>
#include<stdlib.h>
#pragma warning(disable:4996)


typedef struct data1 {
	int n;
	struct data1* next;
}data;

int flag = 0;

data* insertion(data*, int, data*);
data* create();
data* _delete(int);
void scandata(data*);

int main(void) {
	data* head;
	data* creat = create();//创建链表 
	head = creat;
	scandata(creat);

	data ins;// 插入链表 
	data* insert, * cur_head;
	int posit;//插入在posit的前面 
	scanf("%d%d", &ins.n, &posit);//posit从0开始 
	insert = insertion(&ins, posit, head);
	scandata(insert);

	//删除函数
	data* del_head = insert;
	scanf("%d", &posit);
	del_head = _delete(del_head, posit);
	scandata(del_head);

	return 0;
}

void scandata(data* head) {
	while (head->next != NULL) {
		if (head->next->next != NULL)
			printf("%d ", head->n);
		else
			printf("%d", head->n);
		head = head->next;
	}
	puts("");
}

data* create() {
	data* head, * cur, * prev;
	head = (data*)malloc(sizeof(data));
	scanf("%d", &head->n);
	head->next = NULL;
	//prev->next = NULL;千万不能在这里就设置null 
	cur = head;

	while (cur->n != -1) {
		prev = (data*)malloc(sizeof(data));
		scanf("%d", &prev->n);
		prev->next = NULL;
		cur->next = prev;
		cur = prev;
		flag++;
	}
	cur->next = NULL;
	printf("all members: %d\n", flag);
	return head;
}

data* insertion(data* target, int posit, data* head) {
	data* cur, * prev;
	cur = head;
	prev = cur->next;
	int flag = 1;
	if (flag == posit) {
		target->next = head;
		head = target;
		return head;
	}
	while (flag < posit) {
		prev = cur->next;
		flag++;
		if (flag == posit) {
			cur->next = target;
			target->next = prev;
			break;
		}
		cur = prev;
	}
	if (flag > posit) {
		exit(0);
	}
	return head;
}

data* _delete(data* dele_head, int posit) {
	data* cur = dele_head;
	data* prev = cur->next;
	int flag = 1;
	if (flag = posit) {//删除首元素
		dele_head = dele_head->next;
		return dele_head;
	}
	while (flag != posit) {
		flag++;
		if (flag == posit) {
			prev = prev->next;
			cur->next = prev;
		}
		cur = prev;
		prev = prev->next;
	}
	if (flag > posit) {
		printf("error: delete cant found!\n");
		exit(0);
	}
	prev = prev->next;
	cur->next = prev;
	return dele_head;
}
```

